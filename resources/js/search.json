[[{"i":"welcome","l":"Welcome!","p":["Documentacion de Tareas en relacion con Unity"]}],[{"l":"Recursos","p":["link utiles que e encontrado y usado"]},{"l":"Information","p":["Notion del profe","Unity Doc","ChatGBT"]},{"l":"Tutoriales Youtube","p":["Youtube/SpeedTutor","Youtube/samyam","Youtube/iHeartGameDev","Youtube/Brackeys","Youtube/Dave"]},{"l":"Assets","p":["Unity store","link de pags en descripcion"]},{"l":"Programs","p":["Unity","Visual Studio Code"]},{"l":"Discords","p":["Brackeys","Unity"]}],[{"i":"skyhook","l":"“SkyHook”"},{"i":"identidad-del-juegomantra","l":"Identidad del juego/Mantra:","p":["SkyHook: La búsqueda del camino de regreso\"Agárrate fuerte y trepa hacia la libertad\""]},{"i":"pilares-de-diseño","l":"Pilares de diseño:","p":["Mecánicas principales de ganchos y gas para mover al personaje por el entorno.","Historia de exploración en un planeta desconocido, con la megaestructura como principal obstáculo.","Ambiente de ciencia ficción con elementos de misterio y aventura."]},{"l":"Género","p":["Aventura/Acción"]},{"l":"Historia","p":["En un futuro distante, la humanidad ha logrado colonizar otros planetas en galaxias lejanas. Ack, un astronauta, se encuentra en una misión de exploración en un planeta desconocido cuando de repente es sorprendido por una megaestructura colosal que bloquea todas las comunicaciones y deshabilita la navegación de su nave espacial. Atrapado y sin posibilidad de volver a casa, Ack descubre que la megaestructura es obra de una civilización antigua y avanzada tecnológicamente, que ha utilizado materiales magnéticos ultra resistentes para construirla. también descubre un gas muy potente el cual decide recrear en la nave La única manera de avanzar y encontrar una salida es utilizando ganchos especiales creados por la nave para las labores de mantenimiento y reparación más el gas. Poco a poco, Ack va descubriendo que la megaestructura es en realidad una especie de laberinto vertical, diseñado por la civilización para proteger un conocimiento ancestral que podría cambiar el curso de la historia humana. La habilidad con los ganchos se convierte en la única forma de sobrevivir y avanzar en la estructura, mientras la presión y el misterio van aumentando. Además, descubre que cada vez que llega a la cima de una estructura en un nivel, puede desactivar esa estructura en particular, si desactiva todas las estructuras colosales podrá recuperar su nave y volver a casa. Finalmente, después de superar muchos obstáculos y desafíos, Ack descubre que la megaestructura ha sido diseñada como una especie de prueba de selección para encontrar al individuo más capacitado y valiente para recibir el conocimiento ancestral."]},{"i":"mecánicas","l":"Mecánicas:","p":["SkyHook se basa en el uso de ganchos y gas para mover al personaje en el entorno. El jugador dispara ganchos que arrastran al personaje hacia puntos específicos, permitiéndole moverse rápidamente por el entorno. El gas se utiliza para impulsar al personaje hacia adelante y debe ser usado estratégicamente debido a su rápido agotamiento. La combinación de ganchos y gas permite movimientos fluidos y acrobáticos para superar los desafíos y obstáculos del juego. Sin embargo, hay pocos depósitos de gas en la estructura, lo que obliga al jugador a ser cuidadoso en su uso. Si se queda sin gas, deberá volver a la nave para recargar, lo que puede retrasar la misión. Por lo tanto, el uso estratégico del gas es fundamental para cumplir los objetivos a tiempo."]},{"i":"niveles","l":"Niveles:","p":["Ascender consta de tres niveles que se vuelven cada vez más difíciles a medida que se avanza en el juego. Cada nivel presenta una estructura diferente para escalar y el objetivo es llegar a la cima en el menor tiempo posible. El nivel uno es el más sencillo, mientras que el nivel dos presenta la misma estructura que el nivel uno, pero con la diferencia de que cambia de color, lo que hace que el jugador no pueda engancharse por un determinado periodo de tiempo. El nivel tres aumenta la frecuencia en el cambio de color de la estructura, lo que dificulta aún más el ascenso. Además de las dificultades mencionadas, en ciertas zonas de la mega estructura se presentan desafíos adicionales que requieren estrategia por parte del jugador. Por ejemplo, en algunos tramos la estructura puede tener una forma más irregular, lo que dificulta el agarre. También pueden aparecer obstáculos en forma de pequeñas estructuras, que deben ser evitados para no perder tiempo y avanzar más rápido. En el nivel tres, los desafíos son aún mayores, ya que la frecuencia en el cambio de color de la estructura hace que el jugador deba ser aún más preciso y estratégico para alcanzar la cima en el menor tiempo posible."]},{"i":"personajes","l":"Personajes:","p":["Ack: es el protagonista de la historia, un astronauta que se encuentra atrapado en una megaestructura en un planeta desconocido. Es valiente, ingenioso y habilidoso en el uso de los ganchos para avanzar por la estructura. Su objetivo principal es desactivar todas las estructuras colosales para poder recuperar su nave y volver a casa.","Orbe: es un pequeño androide que acompaña a Ack en su viaje por la megaestructura. Su función principal es ayudar a Ack a no caer en la locura a través de la interacción con él y ofrecerle consejos y sugerencias. Es un personaje amigable y servicial, que a menudo proporciona información útil para avanzar en la estructura.","Entidad misteriosa: es una presencia desconocida que se hace evidente a lo largo de la historia, pero cuyo verdadero propósito no se revela hasta el final. Es la entidad que ha construido la megaestructura y ha diseñado la prueba de selección para encontrar al individuo más capacitado y valiente para recibir el conocimiento ancestral. Su presencia y misterio son constantes a lo largo de la historia, lo que agrega un elemento de tensión y misterio a la trama."]},{"i":"características","l":"Características:","p":["Mecánica de cuerdas innovadora para el movimiento del personaje.","Estrategia para poder llegar a la cima sin caer."]},{"l":"Interfaz","p":["La interfaz es muy minimalista, para no distraer al jugador de la acción y mantenerlo concentrado en la escalada. Solo se muestra la cantidad de gas disponible en la parte superior izquierda de la pantalla, en forma de un indicador de barra. En la parte superior derecha de la pantalla, se muestra el tiempo restante en modo contrarreloj y la puntuación en modo clásico. En ambos modos, la interfaz es simple y limpia, para que el jugador pueda centrarse en la tarea de escalar y superar los desafíos de la megaestructura. La pantalla de inicio también es minimalista, con solo tres opciones: \"Jugar\", \"Opciones\" y\"Salir\". En la opción de \"Opciones\", el jugador puede ajustar la configuración de audio y video, así como seleccionar el modo de juego deseado (contrarreloj o clásico). En general, la interfaz de Ascender es intuitiva y fácil de usar, lo que permite al jugador centrarse en la experiencia de la escalada y el desafío de superar la megaestructura."]},{"i":"controles","l":"Controles:","p":["El jugador puede moverse utilizando las teclas \"W\", \"A\", \"S\" y \"D\", con la tecla“SHIFT” da un salto, mientras que los ganchos se disparan con las teclas \"Q\" y \"E\". El botón izquierdo del ratón se utiliza para retraer el gancho, mientras que el botón derecho se utiliza para liberarlo. El gas propulsor se dispara en la dirección opuesta a la orientación de la cámara y se controla con la tecla \"Espacio\". El objetivo es llegar a la cima de la estructura lo más rápido posible, evitando los obstáculos y los peligros en el camino."]},{"i":"otros-modos-de-juego","l":"Otros Modos de juego:","p":["Modo Contrarreloj El jugador tiene un tiempo límite para llegar a la cima de la estructura. Cada nivel presenta un tiempo diferente y el objetivo es superar el tiempo lo más rápido posible.","Modo de supervivencia El jugador debe escalar una estructura cada vez más alta, con la dificultad aumentando a medida que se avanza en el juego. El objetivo es sobrevivir el mayor tiempo posible mientras se evitan los peligros y los obstáculos en el camino."]},{"i":"estilo-de-arte","l":"Estilo de arte:","p":["El juego tiene un estilo de arte low poly, futurista y minimalista, con un enfoque en la funcionalidad. Los entornos están construidos con estructuras geométricas grandes y simples, y los colores son brillantes y vibrantes. Los personajes tienen diseños claramente definidos y detallados, pero sin demasiados adornos o detalles innecesarios que puedan distraer del enfoque en las mecánicas de juego."]},{"i":"músicasonido","l":"Música/Sonido:","p":["La música y los efectos de sonido en SkyHook son dinámicos y energéticos para reflejar la intensidad y emoción de la acción del juego. La música presenta una mezcla de géneros, como electrónica, rock y orquestal, y cambia de ritmo y tono según las situaciones en el juego. Los efectos de sonido son detallados y realistas para aumentar la inmersión en el entorno, desde el sonido de los ganchos disparados hasta los gritos de los enemigos y los sonidos de la estructura en movimiento."]},{"i":"moodboards","l":"Moodboards:","p":["SKYHOOK MOODBOARDS"]},{"i":"plan-de-desarrollocriterios-de-lanzamiento","l":"Plan de desarrollo/Criterios de lanzamiento:","p":["Plataforma: Steam/Google play/iOS/Web.","Audiencia: Jugadores de todas las edades interesados en plataformas de acción y juegos con mecánicas difíciles.","Milestone 1: Mecánicas completas - 01/05/23","Milestone 2: Combates de jefes completos - 0/0/00","Milestone 3: Niveles completos - 20/05/23","Milestone 4: Pulido completo - 30/06/23","Día de lanzamiento: 21/12/23"]}],[{"l":"Tarea 7 Parte 1 Assets","p":["Role: Modelado 3d y assets","Tarea separado en 2 partes el creacion del personaje del jugador y el codigo del movimiento.","Parte 2 El Codigo"]},{"l":"Proceso Modelado","p":["Modelado del personaje ACK","Modelado del casco en base al diseño que hizo mi compañero","Para el resto del cuerpo tome un modelo que encontre en poly.pizza que es un modelo del public domain este modelo lo modifique para adaptarlo mas al diseño original que tenemos para nuestro personaje"]},{"l":"Rigging"},{"l":"Animation utilizando Mixamo","p":["Falling Idle Pack de actiones Sin Animation"]},{"l":"Lista de assets encontrados","p":["AshMoor - Lowpoly Environment by Unvik_3D","Asset pára Orbe","Encaso que nos de ganas de implementar cosas extras no visto en el gdd","Low poly alien world","Low poly Gems","Low Poly Rock Pack","Low Poly Spaceships Set","Low Poly Starship SS01","LOWPOLY - Spaceship","lowpoly environment pack","Lowpoly rocks","Meshtint Free Polygonal Metalon","Obelisk - void","PolyArt - Ancient Village Pack","Posible cambio y modelado debido a que queremos una estetica Low Poly","Real Stars Skybox Lite","Stylized Crystal","uso de holograma para runas","Vast Outer Space"]}],[{"l":"Tarea 7 Parte 2 Codigo"},{"l":"Aplicaciones utilizados de investigacion y guias","p":["lo primero que hice fue buscar la mecanica principal que queriamos hacer que son los ganchos en youtube y en fourms ahi encontre unos pocos pero la que mas me llamo la atencion es la del canal de @davegamedevelopment que tiene tutorials explicativos y con una comunidad que te ayuda cuando teni problemas o si hay mejores formas de hacer ciertas cosas.","Aqui estuve varios horas viendo los videos tutorials que tenia de movimientos basicos, el slide para luego no tener problemas con el tutorial de los ganchos ya que el usa este mismo codigo para el movimiento. suiguiendo los tutorials quitaba lo que no hibamos a usar en el juego y en los comentarios viendo solucciones de problemas que tenia y integrandolos al codigo al mismo tiuempo usando chat GPT para los errores ortograficos o si me salia un error que no entendia porque pasaba."]},{"l":"Codigo","p":["Este explicacion va a ser largo ya que me voy a estar explicando lo que entendi utilizando notas de punteo que ecribi mientras veia los video tutoriales y es harto codigo."]},{"l":"Parte 1 preparando la escena","p":["Inicie creando varios obstaculos y objetos para ir probando el movimiento. Despues me puse a preparar la herarquia importando el model del personaje etc","Cree un empty object llamado CamHolder que es para tener un sustenedor de la camara del jugador que es para no tener problemas ya que lei y escuche que tener la camara como hijo del jugador podria traer problemas.","luego cree otro empty object llamado Player que tiene como hijo al modelo del jugador \"PlayerObj\", La posicion de la camara \"PlayerCam\" y la orientacion de la camara \"Orientation\" que son luegos llamados en un codigo simple para darle la posicion y orientacion a la camara.","El Empty Player es lo que va a contener todo los scrpits y el rigid body del jugador"]},{"l":"Parte 2 El PlayerCam","p":["Iniciamos con el Script PlayerCam que tiene todo lo relacionado con la camara, el suiguimiento del mouse y la rotacion del PlayerObj","Este Codiog esta pegado a la camara del jugador \"PlayerCam\". Este codigo lo explicare usando puntos para cada seccion del codigo.","public float sensX; y public float sensY; son variables publicas que determinan la sensibilidad del movimiento de la camara en los ejes X e Y que despues se pueden ajustar en el inspector.","public Transform orientation; y public Transform playerModel; son referencias a los objetos transform de Unity.","private float yRotation = 0f; y private float xRotation = 0f; son variables privadas que almacenan la rotacion actual de la camara en los ejes Y y X.","En el Start(), se configura el estado del cursor para que este bloqueado y no sea visible.","En el Update(), se obtienen las entradas de movimiento del mouse en los ejes X e Y mediante Input.GetAxisRaw(\"Mouse X\") y Input.GetAxisRaw(\"Mouse Y\"). Estos valores se multiplican por Time.deltaTime para hacer el movimiento suave.","yRotation += mouseX; y xRotation -= mouseY; actualizan las variables de rotacion en funcion de los movimientos del mouse. yRotation se incrementa con el movimiento horizontal del mouse y xRotation se decrementa con el movimiento vertical del mouse.","xRotation = Mathf.Clamp(xRotation, -90f, 90f); asegura que el angulo de rotacion vertical este limitado entre -90 grados y 90 grados para evitar que la camara gire completamente hacia arriba o hacia abajo.","transform.rotation = Quaternion.Euler(xRotation, yRotation, 0); actualiza la rotacion de la camara utilizando la funcion Quaternion.Euler() con los angulos de rotacion actuales.","orientation.rotation = Quaternion.Euler(0, yRotation, 0); actualiza la rotacion del objeto orientation en el eje Y."]},{"l":"Parte 3 El movimiento","p":["El FixedUpdate() se ejecuta en intervalos de tiempo fijos y se utiliza para mover al jugador.","El GetSlopeMoveDirection() calcula la direccion de movimiento en una pendiente utilizando el vector de direccion y la normal de la pendiente.","El Jump() realiza el salto del jugador aplicando una fuerza hacia arriba.","El MovePlayer() mueve al jugador en la direccion y con la velocidad adecuadas, teniendo en cuenta si el jugador esta en una pendiente.","El MyInput() obtiene las entradas del jugador para el movimiento horizontal y vertical, y verifica si se debe realizar un salto.","El OnSlope() verifica si el jugador esta en una pendiente utilizando un raycast y el angulo maximo permitido.","El ResetJump() reinicia el salto permitiendo que el jugador pueda saltar nuevamente.","El SlidingMovement() se encarga del movimiento durante el deslizamiento. Calcula la direccion de entrada utilizando orientation.forward y orientation.right multiplicados por las entradas horizontales y verticales respectivamente. Luego, aplica una fuerza de deslizamiento en funcion de la direccion de entrada normalizada y slideForce. El temporizador de deslizamiento disminuye con el tiempo. Si el jugador esta deslizando hacia abajo por una pendiente, se utiliza pm.GetSlopeMoveDirection() para obtener la direccion de movimiento en la pendiente y se aplica una fuerza de deslizamiento en esa direccion.","El SmoothlyLerpMoveSpeed() se utiliza para realizar una transicion suave entre dos velocidades de movimiento.","El SpeedControl() ajusta la velocidad del jugador para que no supere la velocidad maxima permitida.","El StartSlide() se encarga de iniciar el deslizamiento. Establece pm.sliding en verdadero, cambia la escala en el eje Y del objeto del jugador a slideYScale para que se vea mas bajo, aplica una fuerza hacia abajo al Rigidbody y establece el temporizador de deslizamiento en maxSlideTime.","El StateHandler() determina el estado actual del movimiento del jugador y ajusta la velocidad de movimiento segun el estado. Tambien controla la gravedad y la transicion suave entre diferentes velocidades de movimiento.","El StopSlide() se encarga de detener el deslizamiento. Establece pm.sliding en falso y restaura la escala original en el eje Y del objeto del jugador.","En el FixedUpdate(), si el jugador esta deslizandose (pm.sliding es verdadero), se llama al SlidingMovement() para aplicar la fuerza de deslizamiento.","En el Start(), se asignan las referencias necesarias y se guarda la escala original en startYScale.","En el Start(), se obtiene la referencia al componente Rigidbody y se congela su rotacion. Tambi�n se inicializa la variable readyToJump.","En el Update() Aqu� se verifica si el jugador esta en el suelo, se obtienen las entradas del jugador, se controla la velocidad y se actualiza el estado del movimiento.","En el Update(), se capturan las entradas del jugador y se verifica si se debe iniciar o detener el deslizamiento. Al presionar la tecla slideKey y tener una entrada de movimiento (horizontal o vertical), se llama al StartSlide() para iniciar el deslizamiento. Al soltar la tecla slideKey y si el jugador esta deslizandose, se llama al StopSlide() para detener el deslizamiento.","Esta seccion va a ser largo ya que es harto y es lo que mas me costo.","Este codigo permite al jugador iniciar y detener el deslizamiento al presionar una tecla espec�fica. Durante el deslizamiento, se aplica una fuerza de deslizamiento en la direccion de entrada, lo que permite al jugador moverse rapidamente y de manera controlada.","Este escript se encruentra adjuntado al Player","hice varios notas en un doc donde discribi que hace cada cosa aqui lo dejor de una forma ordenada las cosas que no entendi lo buscaba o utilizaba chat gpt para que me lo explicara de forma clara.","Imagen del inspector","maxSlideTime es la duracion maxima del deslizamiento. slideForce determina la fuerza aplicada durante el deslizamiento. slideYScale es la escala en el eje Y del objeto del jugador cuando esta deslizandose. startYScale almacena la escala original en el eje Y del objeto del jugador.","orientation y playerObj son referencias a los objetos en la escena necesarios para el deslizamiento. rb es una referencia al componente Rigidbody del objeto actual, mientras que pm es una referencia al script PlayerMovement.","private float horizontalInput; y private float verticalInput; almacenan las entradas de movimiento horizontal y vertical del jugador.","private float moveSpeed; y public float walkSpeed;, public float sprintSpeed; y public float slideSpeed; son variables que determinan las velocidades de movimiento del jugador en diferentes situaciones. \"walkSpeed\" es la velocidad al caminar, \"sprintSpeed\" es la velocidad al correr, y \"slideSpeed\" es la velocidad al deslizarse.","private Rigidbody rb; es una referencia al componente Rigidbody del jugador.","private Vector3 moveDirection; es el vector de direccion de movimiento del jugador.","public bool sliding; indica si el jugador esta deslizandose.","public float desiredMoveSpeed; y public float lastDesiredMoveSpeed; son variables que almacenan la velocidad de movimiento deseada y la ultima velocidad deseada del jugador.","public float groundDrag; es la resistencia al arrastre aplicada al jugador cuando esta en el suelo.","public float jumpForce; public float jumpCooldown; y public float airMultiplier; son variables relacionadas con el salto del jugador. \"jumpForce\" determina la fuerza con la que el jugador salta, \"jumpCooldown\" es el tiempo de espera entre saltos, y \"airMultiplier\" es un multiplicador aplicado a la velocidad de movimiento cuando el jugador esta en el aire.","public float maxSlopeAngle;, private RaycastHit slopeHit; y private bool exitingSlope; son variables relacionadas con el manejo de pendientes. \"maxSlopeAngle\" es el angulo maximo de una pendiente en la que el jugador puede caminar, \"slopeHit\" es el resultado de un raycast que detecta la pendiente en la que se encuentra el jugador, y exitingSlope indica si el jugador esta saliendo de una pendiente.","public float playerHeight;, public Transform groundCheck;, public float groundDistance = 0.4f; y public LayerMask whatIsGround; son variables relacionadas con la deteccion del suelo. \"playerHeight\" es la altura del jugador, \"groundCheck\" es un objeto utilizado para verificar si el jugador esta en el suelo, \"groundDistance\" es la distancia a la que se realiza la verificacion y \"whatIsGround\" es la capa que se considera como suelo.","public KeyCode jumpKey = KeyCode.Space; y public KeyCode sprintKey = KeyCode.LeftShift; son las teclas asignadas para saltar y correr.","public MovementState state; es una variable que representa el estado de movimiento del jugador. Puede ser \"walking\" (caminando), \"sprinting\" (corriendo), \"sliding\" (deslizandose) o \"air\" (en el aire).","public Transform orientation; es una referencia al objeto que determina la orientacion del jugador.","slideKey es la tecla que el jugador debe presionar para iniciar y detener el deslizamiento. horizontalInput y verticalInput almacenan las entradas del jugador para el movimiento horizontal y vertical."]}],[{"l":"Tarea 1","p":["Tareas 1 Maximiliano Lira","Imagen de referencia","p7gu6wzpjvm21 Primero cree una esphera y lo posicione después cree un cylinder y le cambie el tamaño de ahí empeces a agregar color a el skybox y a el planeta Capture despues fui agregando arboles y un plano para las nubes Capture1 Al final no me quede muy satisfecho con como quedo, pero con esto me pude familiarizarme más con el programa, con los materiales y el movimiento de los objetos y cámara"]}],[{"l":"Tarea 2","p":["Screenshot 2023-03-22 213927","Empece agruegando los objetos y despues con el script. aqui cree el movimiento usando el Input.GetAxis","Screenshot 2023-03-22 222944 Aqui intente crear la rotacion que no funciono como queria y rotaba el objeto noma","Despues me di cuenta que esto no servia y busque por una forma mas corto y que sirva.","Empece crando una vector3 nuevo rotatedDirection que usa la rotacion y la variable direccion que cree anteriormente para el movimiento despues cree un variable para rotar de forma horizontal con el mouse","https://user-images.githubusercontent.com/75856980/227369357-db29342a-a8ca-4f7c-b014-07cdb618c773.mp4"]}],[{"l":"Tarea 3","p":["image consegui un modelo de lechonk y un tocino mi plan es hacer que aumente su tamaño cada vez que haga colicion con el tocino.","Mejora de movimiento","Una vez ya pensado lo que queria hacer agruegue los movimientos a y d y un salto al script de la Tarea 2","en //Jump estoy haciendo que ejecute el codigo cuando se encruentre encima un superficie y con el espacio apretado el velocity.y = Mathf.Sqrt(jumpHeight * -2f * gravity); calcula la velocidad vertical necesaria utilizando la altura y la gravedad en //Apply gravity agruegue gravedad que se ultilisa en el codigo para el salto y en el controlador","La colision y cambio de tamaño","Agrugue box collider al tocino y a lechonk empece especificando para que cuando choque con el tocino se ejecuta el codigo","aqui utilize el transform para incrementar el tamaño de lechonk en todo los axis","esto no funciono entonces agruegue un debug.log para ver si la collusion ocuria","quitando el is triger lo arreglo la rocka al lado del tocino es el mismo tamaño que lechonk","https://user-images.githubusercontent.com/75856980/229266541-6205db2b-03f6-4e07-8a60-4b4e04d18b52.mp4"]}],[{"l":"Tarea 4","p":["Screenshot 2023-04-09 181446 Lo primero que hice fue crear un living de un apartamento en maya una vez creado lo exporte a unity utilizando la opcion que me da maya Screenshot 2023-04-09 190049 Tuve unas problemas con los muros entonces las borre y las replace por unas creado en unity image lo primero que hice fue mover el sol a un angulo que me gusto y agruegue un reflection probe Screenshot 2023-04-09 203759 ah9i agruegue pointlights y emision a una esphera en el techo junto con un spotlight extirado para iluminar mas Screenshot 2023-04-09 203812 por ultimo agruegue 2 luzes de colores diferentes atras del televisor y un plano que emite luz para la pantalla"]}],[{"l":"Tarea 5","p":["image lo primero que hice fue agruegar fantasmas en la escena de la tarea 4 le cambie unos opciones para hacer el fondo transparente a cada fantasma le agruegue un collider y un animator Luego tome el script del profe y lo modifique","donde cree un variable pública llamada laserPrefab que se utilizará para generar un rayo láser cuando se destruya un objeto de juego. Dentro del bloque if (Physics.Raycast (ray, out hit)), agruegue dos líneas de código. La primera línea llama a Destroy (hit.collider.gameObject) para destruir el objeto del juego que fue golpeado por el rayo. La segunda línea usa Instantiate para crear una nueva instancia del objeto de juego laserPrefab en el punto donde el rayo golpeó el objeto de juego. image esto genero varios laseres o lines de luz donde se destruyo el fantasma pero no quitaba los lasers entonces agrege una variable de float pública llamada laserLifetime que me deja darle un tiempo en que este visible el laser y 2 lineas de codigo que destuira el laser en el tiempo determinado por el laserLiftime"]}],[{"l":"Tarea 6","p":["image Voy a explicar lo que hice y explicando el codigo utilizando comentarios Lo primero que hice fue crear el canvas con todo las cosas que vimos en clase creando paneles y text ui uno para el nombre \"Time\" y \"Cubes\" y otros para los textos que se van a ir cambiando segun los scripts","Despues de eso cree el Game Manager y el script para los cubos y el ray cast. en el ray cast use la que vimos en clases ya que es la conocia en lo siguiente dejo el script de ScreenRaycast que maneja la interacción del mouse con objetos en la pantalla. explicare solo las líneas de código que estan relacionado con el contador ya que el resto ya sea visto en las tareas pasado utilizare comentarios para explicar:","Este script lo tengo agruegado como component para el Gamemanager donde le assigno al text (UI) \"NumCube\" que tengo en el canvas","Ahora voy a explicar el contador de tiempo donde cree un script llamado \"Timer\" que tambein lo asigno al Gamemanager y hago lo mismo que para lo anterior en lo siguiente explicare el Script","el siguiente video mostrara el resultado final"]}]]